<!DOCTYPE HTML>
<html>
  <head>
    <title>Arc</title>
    <style>
      body {
        background-color: #050505;
        margin: 0px;
        padding: 0px;
      }
      div.color-button.checkered3 {
        background-size: 34px 34px;
        background-position: 0 0, 17px 17px;
        background-image: linear-gradient(45deg, #fffbd2 25%, transparent 25%, transparent 75%, #fffbd2 75%, #fffbd2),
                          linear-gradient(45deg, #fffbd2 25%, transparent 25%, transparent 75%, #fffbd2 75%, #fffbd2);
      }
      .container {
        /*width: 1340px;*/
        margin: 0 auto;
      }
      #myCanvas {
        background-color: #000
        transform: scale(1);
        transform-origin: 0 0;
        cursor: pointer;
        border: 1px solid #555;
      }
      .canvas-wrapper {
        display: inline-block;
        padding: 1px;
      }
      .color-button {
        display: inline;
        width: 50px;
        height: 50px;
        margin: 10px 23px;
        background-color: #ff0;
        border: 4px solid black;
        border-radius: 40px;
      }
      .color-button:hover {
        cursor: pointer;
        border: 4px solid cyan;
      }
      .color-button.selected {
        border: 4px solid aliceblue;
      }
      #toolbar {
        display: inline-block;
        width: 110px;
        vertical-align: top;
      }
      #toolbar {
        display: none;
      }
      #toolbar div {
        display: inline-block;
      }
      div#cc {
        display: none;
      }
      div#pattern {
        /*display: none;*/
      }
      #fullscreen #goFS {
        display: none;
        vertical-align: middle;
        padding: 10px;
        margin: 10px 30px;
      }
      #fpsDisplay {
        display: none !important;
        color: #ccc;
        font-family: Arial, sans-serif;
        text-align: center;
      }
      #misc {
        display: none;
      }
    </style>
  </head>

  <body>
    <div class="container">
      <div class='canvas-wrapper' id='putCanvasHere'>
        <!-- <canvas id="myCanvas" width="1200" height="800"></canvas> -->
      </div>
      <div id="toolbar">
        <div id="fpsDisplay"></div>
        <div id="pulsar-buttons"></div>
        <div id="fullscreen">
          <button id="goFS">FS</button>
        </div>
      </div>
    </div>

    <div id="misc">
      <div id="pattern">
        <canvas id="patternCanvas" width="100" height="100"></canvas>
      </div>
      <div id="cc">
        <img id="canvasCopy" style="width:50px; height:50px; border: 1px solid gray;" onclick="copyCanvas()">
      </div>
    </div>


    <script src="lib/jquery.min.js"></script>
    <script src="lib/three.min.js"></script>
    <script src="lib/thing.js"></script>


    <script src="js/tinycolor/tinycolor.js"></script>
    <script src="js/MainLoop.js"></script>
    <script src="js/Shapes.js"></script>
    <script src="js/Intersections.js"></script>
    <script src="js/Pulsar.js"></script>
    <script src="js/TextureFactory.js"></script>
    <script src="js/BlendedDrawing.js"></script>
    <script src="js/HUD.js"></script>
    <script src="js/UIListener.js"></script>
    <script src="js/ArcField.js"></script>

    <script id="fragment_shader_screen" type="x-shader/x-fragment">
      varying vec2 vUv;
      uniform sampler2D tDiffuse;

      void main() {
        gl_FragColor = texture2D( tDiffuse, vUv );
      }
    </script>

    <script id="vertexShader" type="x-shader/x-vertex">
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    </script>

    <script>
      var renderer, texture;
      var drawing, HUD;
      var textures;
      var textureFactory;

      // SHAPES //////////////////////////////////////////////////////////////////////////
      function mapUVsToWidth(uvArray, geometryWidth) {
        for (let i=0; i < uvArray.length; i++) {
          uvArray[i] = uvArray[i] / geometryWidth;
        }
      }

      function mapUVsToWidthRing(geometry, geometryWidth) {
        var verts = geometry.attributes.position.array;
        var uvs = geometry.attributes.uv.array;
        for (let p=0, t=0; p < verts.length; p += 3, t += 2) {
          uvs[t] = verts[p] / geometryWidth;
          uvs[t+1] = verts[p+1] / geometryWidth;
        }
      }

      function makeCircle(x, y, z, r) {
        var geometry = new THREE.CircleGeometry( r, 360 ); // radius, segments
        var mesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { side: THREE.DoubleSide, map: texture } ) );
        mesh.position.set( x, y, z );
        // mesh.rotation.set( 0, 0, 0 );
        // mesh.scale.set( 1, 1, 1 );
        return mesh;
      }

      function makeArc(x, y, z, r, color, txture) {
        var circleRadius = r;
        var geometry = new THREE.RingBufferGeometry( (r >= 100 ? r - 100 : 0), r, 60, 1, 0, 1.6 * Math.PI);

        mapUVsToWidthRing(geometry, 600);

        // var mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, map: txture } ) );
        var mesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: color, transparent: true, opacity: 0.3, side: THREE.DoubleSide, map: txture } ) );
        mesh.position.set( x, y, z );

        return mesh;
      }

      function createCirclePoints(numPoints, radius) {
        var points = [],
          angle,
          x,
          y,
          i;
        for (i=0; i<numPoints; i++) {
          angle = (i / (numPoints/2)) * Math.PI; // Calculate the angle at which the element will be placed.
          x = (radius * Math.cos(angle)); // Calculate the x position of the element.
          y = (radius * Math.sin(angle)); // Calculate the y position of the element.
          points.push({'id': i, 'x': x, 'y': y});
        }
        return points;
      }

      function jiggle(points, howmuch) {
        for (var n=0; n < points.length; n++) {
          points[n].x += points[n].x * (Math.random() * howmuch);
          points[n].y += points[n].y * (Math.random() * howmuch);
        }
        return points;
      }

      function makeFlowerShape(txtrArray) {
        // var heartShape = new THREE.Shape(); // From httshapp://blog.burlock.org/html5/130-paths
        // heartShape.moveTo( 25, 25 ); // 1
        // heartShape.bezierCurveTo( 25, 25, 20, 0,      0, 0 );  // 2
        // heartShape.bezierCurveTo( -30, 0, -30, 35,  -30, 35 ); // 3
        // heartShape.bezierCurveTo( -30, 55, -10, 77,   25, 95 ); // 4
        // heartShape.bezierCurveTo( 60, 77, 80, 55,     80, 35 ); // 5
        // heartShape.bezierCurveTo( 80, 35, 80, 0,      50, 0 ); // 6
        // heartShape.bezierCurveTo( 35, 0, 25, 25,      25, 25 ); // 7

        function randPetals() {
          return 5 + Math.floor(Math.random() * 7);
        }

        // bezierCurveTo( from control point x, y,    to control point x, y,   to new point x, y)
        var daisy = new THREE.Shape();
        var numPetals = randPetals();
        var jiggleAmount = 0.1 + (Math.random() * 1.5);
        var outerRadius = Math.floor(100 + ( Math.random() * 250));
        var innerRadius = Math.floor(40 + (Math.random() * (outerRadius * 0.75)));
        var innerPoints = jiggle(createCirclePoints(numPetals, 50), jiggleAmount);
        var outerPoints = jiggle(createCirclePoints(numPetals, 250), jiggleAmount);
        daisy.moveTo( innerPoints[0].x, innerPoints[0].y );

        for (var n = 1; n < innerPoints.length; n++) {
          daisy.bezierCurveTo(
            outerPoints[n-1].x, outerPoints[n-1].y,
            outerPoints[n].x, outerPoints[n].y,
            innerPoints[n].x, innerPoints[n].y );
        }

        daisy.bezierCurveTo(
          outerPoints[innerPoints.length-1].x, outerPoints[innerPoints.length-1].y,
          outerPoints[0].x, outerPoints[0].y,
          innerPoints[0].x, innerPoints[0].y );

        var geometry = new THREE.ShapeBufferGeometry(daisy, 60);
        mapUVsToWidthRing(geometry, outerRadius);

        var textureId = Math.floor(Math.random()*txtrArray.length);
        var mat = new THREE.MeshBasicMaterial( { color: 0xF6F300, side: THREE.DoubleSide, map: txtrArray[textureId] } );
        var mesh = new THREE.Mesh(geometry, mat);
        mesh.position.set( 500 + Math.floor(Math.random() * 800), -(300 + Math.floor(Math.random() * 500)), -75 );

        return mesh;
      }

      function makeQuad(x, y, z, w, h, t) {
        var plane = new THREE.PlaneBufferGeometry(w, h);
        var mat = new THREE.MeshBasicMaterial({ color: 0xF6FC00, side: THREE.DoubleSide, map: t });
        var quad = new THREE.Mesh(plane, mat);
        quad.position.set(x, y, z);
        return quad;
      }

      ////////////////////////////////////////////////////////////////////////////////////

      function onWindowResize() {
        // todo: propogate new window size to drawing and HUD
        // renderer.setSize( window.innerWidth, window.innerHeight );
      }

      function update(delta) {
        drawing.update(delta);
        ArcField.update(delta);
        HUD.update();
      }

      function render() {
        // redraw animation
        ArcField.draw();

        // render drawing into texture
        drawing.render();

        // render drawing + overlay to screen
        HUD.render();
      }

      function animate() {
        MainLoop.setDraw(render);
        MainLoop.setUpdate(update);
        MainLoop.start();
      }

      function makeTexture(textureFileURL) {
        var loader = new THREE.TextureLoader();
        texture = loader.load(textureFileURL);
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.minFilter = THREE.LinearFilter,
        texture.magFilter = THREE.LinearFilter,
        texture.generateMipmaps = true;
        texture.needsUpdate = true;
        texture.repeat.set(2, 2);
        return texture;
      }

      function makeRenderer(w, h, dpr) {
        var renderer = new THREE.WebGLRenderer({alpha: true, antialias: true}); // premultipliedAlpha, antialias: true
        renderer.autoClearColor = 0x000000;
        // var renderer = new THREE.WebGLRenderer({preserveDrawingBuffer: true});
        // renderer.autoClearColor = false;
        renderer.setPixelRatio( dpr );
        renderer.setSize(w, h);
        return renderer;
      }

      ////////////////////////////////////////////////////////////////////////////////

      function addStuffToDrawing(scene, rendrr, txtrArray) {
        // var light = new THREE.DirectionalLight( 0xffffff, 1 );
        // light.position.set( 0, 0, 1 ).normalize();
        // scene.add( light );

        scene.add( makeCircle(300, -200, 200, 100) );

        var w = rendrr.getSize().width * 0.33;
        var h = rendrr.getSize().height;
        scene.add( makeQuad((w/2) + 100, -h/2, -300, w, h, textures[1]) );

        scene.add( makeFlowerShape(txtrArray) );
      }

      function addStuffToHUD(scene, txtr) {
        var material = new THREE.MeshBasicMaterial( { color: 0xF6F300, side: THREE.DoubleSide, map: txtr } );
        var geometry = new THREE.CircleGeometry( 50, 360 ); // radius, segments
        var mesh = new THREE.Mesh( geometry, material );
        mesh.position.set( 150, -100, -50 );
        scene.add( mesh );

        // var light = new THREE.DirectionalLight( 0xffffff, 1 );
        // light.position.set( 0, 0, 1 ).normalize();
        // scene.add( light );
      }

      function makeFlowerScene(scene) {
        var flower = makeFlowerShape(textures);
        flower.position.set( 0, 0, 20 );
        scene.add( makeCircle(0, 0, 30, 50) );
        scene.add( flower );
      }

      function init() {
        var imageNames = [
          { src:'img/red_on_white_floral_pattern.jpg' },
          { src:'img/gold_leaf_bg_bright.png' },
          { src:'img/USA_flag_starfield_seamless.png' },
          { src:'img/ftiles.jpg' },
          { src:'img/wood_panelling.jpg' },
          { src:'img/watermelon.jpg' },
          { src:'img/yellowfreeaccess.jpg' },
          { src:'img/twit_logo_blue_crop_t.png' },
          { src:'img/twits_in_circle.png' },
          { src:'img/skin_with_water_droplets.png' },
          { src:'img/Checkerboard_pattern.png' },
          { src:'img/youtube-play-button_red_on_white.png' },
          { src:'img/youtube_play_button_white_on_red_1.png' },
        ];
        var texture2;

        Thing.Img.loadBatch(imageNames, (imgs) => {
          textures = [
            makeTexture('img/red_on_white_floral_pattern.jpg'),
            makeTexture('img/gold_leaf_bg_bright.png'),
            makeTexture('img/USA_flag_starfield_seamless.png'),
            makeTexture('img/ftiles.jpg'),
            makeTexture('img/wood_panelling.jpg'),
            makeTexture('img/watermelon.jpg'),
            makeTexture('img/yellowfreeaccess.jpg'),
            // makeTexture('img/orange_water_drops_256.png'),
            makeTexture('img/twit_logo_blue_crop_t.png'),
            makeTexture('img/twits_in_circle.png'),
            makeTexture('img/skin_with_water_droplets.png'),
            // makeTexture('img/metal_button_1.png'),
            makeTexture('img/Checkerboard_pattern.png'),
            makeTexture('img/youtube-play-button_red_on_white.png'),
            makeTexture('img/youtube_play_button_white_on_red_1.png'),
          ];

          texture = textures[ Math.floor(Math.random() * textures.length) ];
          texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
          texture.offset.set(0, 0);
          texture.repeat.set(4, 4);

          // create the webgl canvas
          renderer = makeRenderer(window.innerWidth * 0.99, window.innerHeight * 0.99, window.devicePixelRatio);

          // add the webgl canvas to document
          document.getElementById('putCanvasHere').appendChild( renderer.domElement );
          window.addEventListener('resize', onWindowResize, false );

          // Builds textures for use in drawing
          textureFactory = makeTextureFactory(renderer);
          texture2 = textureFactory.getTexture2();

          // Draws shapes without clearing canvas (blends into offscreen buffer)
          drawing = makeBlendedDrawing(renderer);
          addStuffToDrawing(drawing.scene, renderer, textures);

          // Renders the drawing layer and additional shapes that do not blend 
          HUD = makeHUD(renderer, drawing.getTexture());
          addStuffToHUD(HUD.scene, texture2);

          // bogus way to wait for textures images to load
          setTimeout(() => {
            // render a flower and copy to texture
            textureFactory.render(makeFlowerScene);
            texture2 = textureFactory.getTexture2();

            textures.push(texture2);
            textures.push(texture2);
            textures.push(texture2);
            textures.push(texture2);

            HUD.addQuadWithTexture(drawing.getTexture());
            // HUD.addQuadWithTexture(textureFactory.getTexture2());

            // arcfield will render into drawing layer
            window.ArcField.init(renderer, drawing.scene, textures);

            // start the rendering loop
            animate();
          }, 500);
        });

      }

      init();

    </script>

  </body>
</html>
